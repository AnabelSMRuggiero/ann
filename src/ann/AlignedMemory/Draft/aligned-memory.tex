\documentclass[11pt]{article}

\usepackage{listings}

\usepackage{geometry}
\geometry{margin=1in}

\title{Aligned memory: \texttt{aligned\_allocator} and \texttt{aligned\_span}}
\author{Anabel S. M. Ruggiero}

\begin{document}
\maketitle

\section{Introduction}\label{intro}

This paper is intended to propose additions to complete a minimum set of essentials to provide 

\begin{itemize}
\item a safe interface to aligned \texttt{operator new} and \texttt{operator delete},
\item embed properties of the memory into types without affecting the types of the objects on the aligned memory,
\item and leverage the optimizations compilers currently provide for aligned memory loads.
\end{itemize}

The additions proposed in this paper, \texttt{aligned\_allocator} and \texttt{aligned\_span}, along with\texttt{vector} and \texttt{assume\_aligned} and are what the author understands to be the minimum essentials.

\section{Motivation}
Motivation: SIMD operations
	Different sets of instructions to handle loading based on alignment
		x86:
			SSE - align to 16 bytes or segfault trying
			AVX - movups No alignment requirement beyond that of \texttt{float},  movaps requires alignment to 32 bytes, but can yield better performance dependent on the target processor.
	Why this matters:
		load speeds are a typical limiting step in a computation:
			Put benchmarks here
			
\subsection{What the Standard Already Provides}
C++11 introduced overaligned types to the language. Using this feature, a struct wrapping a fixed sized array of 8 \texttt{float}s could be used to force alignments, but this requires taking a hit to ergonomics. Instead of accessing an array of floats, you have to work with array of this wrapping type. However, treating the alignment as a property of the memory and not a property of the objects that sit on it resolves the awkwardness of working with wrapper types.

In C++17, alignment aware overloads of \texttt{operator new} were added to the language. While C introduced \texttt{aligned\_alloc} in C11, \texttt{aligned\_alloc} was not added to the C++ standard library until C++17. While \texttt{new} expressions supported over aligned types since C++11, this was the first time a standard interface to the underlying aligned memory allocation was exposed. This also exposed access to form of placement new that would allocate memory, construct an object... and immediately render your program ill-formed.
	%Check for specific wording from the standard.
Since the already discouraged new expression does not work for aligning the underlying memory, this leaves a direct, raw call to \texttt{::operator new}... or to look to the idiomatic interface for handling memory and construction as disjoint operations: allocators. \texttt{std::pmr::polymorphic\_allocator} provides an interface for aligned memory allocation. However, avoiding the runtime overhead of an alignment check either requires part of the semantics of the program to remain implicit, or embedding that information in as part of a static type. One possibility is to have alignment be a property of a container, but embedding the information into an allocator provides this with a minimal addition to the standard.

\subsection{The Bare Essentials}

[Godbolt link] shows all that the components listed in section \ref{intro} together enables GCC and Clang to emit aligned loads for elements in the vectors. \texttt{vector<float, allocator<float>>} and \texttt{vector<float, aligned\_allocator<float, 32>>} both result in only \texttt{vmovups} emitted in the compiled assembly. Only calling \texttt{EuclideanNorm} with \texttt{aligned\_span<float, 32>} provide GCC and Clang with the information necessary to emit \texttt{vmovaps} instructions. This ensemble effect can still be disrupted by changing a single implementation detail: removing the call to \texttt{assume\_aligned} in \texttt{aligned\_span::data()}, which is used in \texttt{aligned\_span::begin()}.

\section{Impact On The Standard}

This proposal only proposes additions to the standard library.

\section{Design Decisions}

As suggested above, element wrappers were explicitly a design that was avoided.

Container based designs were considered, but still requires the container's allocator to provide an interface to some form of aligned memory allocation through `std::allocator\_traits`.

An other possible space for \texttt{aligned\_span} is a version of \texttt{span} that offers more general customization. For example, the currently proposed \texttt{mdspan} allows customization of behavior through the \texttt{layout} and \texttt{accessor} template parameters. The difference in behavior between \texttt{aligned\_span} and \texttt{span} is conceptually similar to using an \texttt{aligned\_right} or \texttt{aligned\_left} layout policy in \texttt{mdspan}.

The designs of \texttt{aligned\_allocator} and \texttt{aligned\_span} closely mirror those of \texttt{std::allocator} and \texttt{std::span}, respectively.

Remaining design questions
\begin{itemize}
	\item type of align template parameter, \texttt{size\_t} is more ergonomic due to not being a scoped enum, but \texttt{align\_val\_t} matches the \texttt{operator new} overload.
	\item contiguous iterator overload of \texttt{assume\_aligned}?
	\item expose type traits/concepts for detecting aligned contiguous ranges?
	\item implementation defined default alignment parameter?
	\item how should fixed-sized \texttt{aligned\_span}s be exposed? 
\end{itemize}

Questions regarding direct interaction with containers will be raised in array paper.

\section{Technical Specification: \texttt{aligned\_allocator}}

\subsection{Additions to Header \texttt{<memory>} synopsis [memory.syn]}

\begin{itemize}
	\item In 20.2.2 [memory.syn], add the following class template and function declarations after the declarations for \texttt{allocator}:
\end{itemize}

\begin{lstlisting}[language=C++, basicstyle=\small]
// [aligned.allocator], the aligned allocator
template<class T> class aligned_allocator;

template<class T, class U>
template<typename T, typename U, align_val_t Align>
  constexpr bool operator==(
    const aligned_allocator<T, Align>&, 
    const aligned_allocator<U, Align>&) noexcept;

template<typename T, align_val_t TAlign,
         typename U, align_val_t UAlign>
  requires (TAlign != UAlign)
  constexpr bool operator==(
    const aligned_allocator<T, TAlign>&, 
    const aligned_allocator<U, UAlign>&) noexcept;
\end{lstlisting}

\subsection{New Subclauses}

In the following subsections, \textit{X}, will be used as a placeholder section number.

\subsubsection{20.2.\textit{X}	The aligned allocator	[aligned.allocator]}

\textit{No text is proposed for this subclause.}

\subsubsection{20.2.\textit{X}.1	General	[aligned.allocator.general]}

All specialization of the aligned allocator meet the allocator completeness requirements ([allocator.requirements.completeness]).

\begin{lstlisting}[language=C++, basicstyle=\small]
namespace std {
  template<class T, align_val_t Align> class aligned_allocator {
   public:
    using value_type                             = T;
    using size_type                              = size_t;
    using difference_type                        = ptrdiff_t;
    using propagate_on_container_move_assignment = true_type;
    
    template<class U> struct rebind{
      using other = aligned_allocator<U, Align>;
    };
    
    static constexpr align_val_t alignment       = Align

    constexpr aligned_allocator() noexcept;
    constexpr aligned_allocator(const aligned_allocator&) noexcept;
    template<class U> constexpr aligned_allocator(const aligned_allocator<U, Align>&) noexcept;
    constexpr ~aligned_allocator();
    constexpr aligned_allocator& operator=(const aligned_allocator&) = default;

    [[nodiscard]] constexpr T* allocate(size_t n);
    [[nodiscard]] constexpr T* allocate(size_t n, align_val_t req_align);
    [[nodiscard]] constexpr allocation_result<T*> allocate_at_least(size_t n);    
    [[nodiscard]] constexpr allocation_result<T*> allocate_at_least(size_t n, align_val_t req_align);
    constexpr void deallocate(T* p, size_t n);
    constexpr void deallocate(T* p, size_t n, align_val_t req_align);
  };
}

\end{lstlisting}
\noindent
\texttt{allocator\_traits<aligned\_allocator<T, Align>>::is\_always\_equal::value} is \texttt{true} for any \texttt{T} and \texttt{Align}.

\subsubsection{20.2.\textit{X}.2	Members	[aligned.allocator.members]}

Except for the destructor, member functions of the aligned allocator shall not introduce data races ([intro.multithread]) as a result of concurrent calls to those member functions from different threads.
Calls to these functions that allocate or deallocate a particular unit of storage shall occur in a single total order, and each such deallocation call shall happen before the next allocation (if any) in this order.

\begin{lstlisting}[language=C++, basicstyle=\small]
[[nodiscard]] constexpr T* allocate(size_t n);
\end{lstlisting}
\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Mandates:} T is not an incomplete type ([basic.types.general]).

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Returns:} A pointer to the initial element of an array of \texttt{n T}. The pointer shall have an alignment of at least \texttt{Align} and behave as if the result of a call to \texttt{assume\_aligned<Align, T>}.

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Throws:} \texttt{bad\_array\_new\_length} if \texttt{numeric\_limits<size\_t>::max() / sizeof(T) < n}, or \texttt{bad\_alloc} if the storage cannot be obtained.

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Remarks:} The storage for the array is obtained by calling the aligned overload of \texttt{::operator new} ([new.delete]), but it is unspecified when or how often this function is called. This function starts the lifetime of the array object, but not that of any of the array elements.

\begin{lstlisting}[language=C++, basicstyle=\small]
[[nodiscard]] constexpr T* allocate(size_t n, align_val_t req_align);
\end{lstlisting}

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Mandates:} T is not an incomplete type ([basic.types.general]).

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Returns:} A pointer to the initial element of an array of \texttt{n T}. The pointer shall have an alignment of at least \texttt{max(Align, req\_align)} and behave as if the result of a call to \texttt{assume\_aligned<Align, T>}.

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Throws:} \texttt{bad\_array\_new\_length} if \texttt{numeric\_limits<size\_t>::max() / sizeof(T) < n}, or \texttt{bad\_alloc} if the storage cannot be obtained.

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Remarks:} The storage for the array is obtained by calling the aligned overload of \texttt{::operator new} ([new.delete]), but it is unspecified when or how often this function is called. This function starts the lifetime of the array object, but not that of any of the array elements.

\begin{lstlisting}[language=C++, basicstyle=\small]
[[nodiscard]] constexpr allocation_result<T*> allocate_at_least(size_t n); 
\end{lstlisting}
\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Mandates:} T is not an incomplete type ([basic.types.general]).

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Returns:} \texttt{allocation\_result<T*>{ptr, count}}, where \texttt{ptr} is a pointer to the initial element of an array of \texttt{count T} \textbf{and} \texttt{count >= n}. \texttt{ptr} shall have an alignment of at least \texttt{Align} and behave as if the result of a call to \texttt{assume\_aligned<Align, T>}.

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Throws:} \texttt{bad\_array\_new\_length} if \texttt{numeric\_limits<size\_t>::max() / sizeof(T) < n}, or \texttt{bad\_alloc} if the storage cannot be obtained.

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Remarks:} The storage for the array is obtained by calling the aligned overload of \texttt{::operator new} ([new.delete]), but it is unspecified when or how often this function is called. This function starts the lifetime of the array object, but not that of any of the array elements.

\begin{lstlisting}[language=C++, basicstyle=\small]
[[nodiscard]] constexpr allocation_result<T*> allocate_at_least(size_t n, align_val_t req_align);
\end{lstlisting}

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Mandates:} T is not an incomplete type ([basic.types.general]).

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Returns:}\texttt{allocation\_result<T*>{ptr, count}}, where \texttt{ptr} is a pointer to the initial element of an array of \texttt{count T} \textbf{and} \texttt{count >= n}. \texttt{ptr} shall have an alignment of at least \texttt{max(Align, req\_align)} and behave as if the result of a call to \texttt{assume\_aligned<Align, T>}.

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Throws:} \texttt{bad\_array\_new\_length} if \texttt{numeric\_limits<size\_t>::max() / sizeof(T) < n}, or \texttt{bad\_alloc} if the storage cannot be obtained.

\noindent
\hangindent=1.05cm\hspace{1cm}\textit{Remarks:} The storage for the array is obtained by calling the aligned overload of \texttt{::operator new} ([new.delete]), but it is unspecified when or how often this function is called. This function starts the lifetime of the array object, but not that of any of the array elements.
\begin{lstlisting}[language=C++, basicstyle=\small]
constexpr void deallocate(T* p, size_t n);
\end{lstlisting}

\hangindent=1.05cm\hspace{1cm}\textit{Preconditions:} If \texttt{p} is memory that was obtained by a call to \texttt{allocate\_足at\_足least(size_t)}, let \texttt{ret} be the value returned and \texttt{req} be the value passed as the first argument to that call. \texttt{p} is equal to \texttt{ret.ptr} and \texttt{n} is a value such that \texttt{req <= n <= ret.count}.
Otherwise, \texttt{p} is a pointer value obtained from \texttt{allocate(size_t)}.
\texttt{n} equals the value passed as the first argument to the invocation of allocate which returned \texttt{p}.


\hangindent=1.05cm\hspace{1cm}\textit{Effects:} Deallocates the storage referenced by p.

\hangindent=1.05cm\hspace{1cm}\textit{Remarks:} Uses an aligned overload of ::operator delete ([new.delete]), but it is unspecified when this function is called.

\begin{lstlisting}[language=C++, basicstyle=\small]
constexpr void deallocate(T* p, size_t n, align_val_t req_align);
\end{lstlisting}

\hangindent=1.05cm\hspace{1cm}\textit{Preconditions:} If \texttt{p} is memory that was obtained by a call to \texttt{allocate\_足at\_足least(size_t, align_val_t)}, let \texttt{ret} be the value returned, \texttt{req} be the value passed as the first argument to that call, and \texttt{align} be the value passed as the second argument to that call. \texttt{p} is equal to \texttt{ret.ptr}, \texttt{n} is a value such that \texttt{req <= n <= ret.count}, and \texttt{req_align} is equal to \texttt{align}.
Otherwise, \texttt{p} is a pointer value obtained from \texttt{allocate(size_t, align_val_t)}.
\texttt{n} equals the value passed as the first argument and \texttt{req_align} equals the value passed as the second argument to the invocation of \texttt{allocate} which returned \texttt{p}.


\hangindent=1.05cm\hspace{1cm}\textit{Effects:} Deallocates the storage referenced by p.

\hangindent=1.05cm\hspace{1cm}\textit{Remarks:} Uses an aligned overload of ::operator delete ([new.delete]), but it is unspecified when this function is called.

\subsubsection{20.2.\textit{X}.3	Operators	[aligned.allocator.globals]}
\begin{lstlisting}[language=C++, basicstyle=\small]
template<class T, class U>
template<typename T, typename U, align_val_t Align>
  constexpr bool operator==(
    const aligned_allocator<T, Align>&, 
    const aligned_allocator<U, Align>&) noexcept;
\end{lstlisting}
\hangindent=1cm \hspace{1cm} \textit{Returns:} \texttt{true}.

\begin{lstlisting}[language=C++, basicstyle=\small]
template<typename T, align_val_t TAlign,
         typename U, align_val_t UAlign>
  requires (TAlign != UAlign)
  constexpr bool operator==(
    const aligned_allocator<T, TAlign>&, 
    const aligned_allocator<U, UAlign>&) noexcept;
\end{lstlisting}
\hangindent=1cm \hspace{1cm} \textit{Returns:} \texttt{false}.

\section{Technical Specification: \texttt{aligned\_span}}

\subsection{Changes to subclause 24.7.1 [views.general]}

\begin{itemize}
	\item Change ''The header \texttt{<span>} defines the view \texttt{span}.`` to ``The header \texttt{<span>} defines the views \texttt{span} and \texttt{aligned_span}.''
\end{itemize}

\subsection{Additions to Header \texttt{<span>} synopsis [span.syn]}

\begin{itemize}
	\item In 24.7.2 [span.syn], add the following class template and function declarations after the declarations for \texttt{span}:
\end{itemize}

\begin{lstlisting}[language=C++, basicstyle=\small]
// [views.aligned.span], class template aligned_span
  template<class ElementType, size_t Extent = dynamic_extent>
    class span;

  template<class ElementType, size_t Extent>
    inline constexpr bool ranges::enable_view<span<ElementType, Extent>> = true;
  template<class ElementType, size_t Extent>
    inline constexpr bool ranges::enable_borrowed_range<span<ElementType, Extent>> = true;

  // [aligned.span.objectrep], views of object representation
  template<class ElementType, size_t Extent>
    span<const byte, Extent == dynamic_extent ? dynamic_extent : sizeof(ElementType) * Extent>
      as_bytes(span<ElementType, Extent> s) noexcept;

  template<class ElementType, size_t Extent>
    span<byte, Extent == dynamic_extent ? dynamic_extent : sizeof(ElementType) * Extent>
      as_writable_bytes(span<ElementType, Extent> s) noexcept;
\end{lstlisting}

\end{document}